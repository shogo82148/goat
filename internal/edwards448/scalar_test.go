package edwards448

import (
	"testing"
	"testing/quick"
)

func TestSetCanonicalBytes(t *testing.T) {
	t.Run("valid input", func(t *testing.T) {
		s := NewScalar()
		_, err := s.SetCanonicalBytes([]byte{
			0xf2, 0x44, 0x58, 0xab, 0x92, 0xc2, 0x78, 0x23,
			0x55, 0x8f, 0xc5, 0x8d, 0x72, 0xc2, 0x6c, 0x21,
			0x90, 0x36, 0xd6, 0xae, 0x49, 0xdb, 0x4e, 0xc4,
			0xe9, 0x23, 0xca, 0x7c, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
			0x00,
		})
		if err != nil {
			t.Fatal(err)
		}
		if s.Equal(NewScalar()) == 1 {
			t.Fatal("s should not be zero, but it is")
		}
	})

	t.Run("not reduced", func(t *testing.T) {
		s := NewScalar()
		_, err := s.SetCanonicalBytes([]byte{
			0xf3, 0x44, 0x58, 0xab, 0x92, 0xc2, 0x78, 0x23,
			0x55, 0x8f, 0xc5, 0x8d, 0x72, 0xc2, 0x6c, 0x21,
			0x90, 0x36, 0xd6, 0xae, 0x49, 0xdb, 0x4e, 0xc4,
			0xe9, 0x23, 0xca, 0x7c, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
			0x00,
		})
		if err == nil {
			t.Fatal(err)
		}
		if s.Equal(NewScalar()) == 0 {
			t.Fatal("s should be zero, but it is not")
		}
	})

	t.Run("invalid Most Significant Bit", func(t *testing.T) {
		s := NewScalar()
		_, err := s.SetCanonicalBytes([]byte{
			0xf2, 0x44, 0x58, 0xab, 0x92, 0xc2, 0x78, 0x23,
			0x55, 0x8f, 0xc5, 0x8d, 0x72, 0xc2, 0x6c, 0x21,
			0x90, 0x36, 0xd6, 0xae, 0x49, 0xdb, 0x4e, 0xc4,
			0xe9, 0x23, 0xca, 0x7c, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
			0x80,
		})
		if err == nil {
			t.Fatal(err)
		}
		if s.Equal(NewScalar()) == 0 {
			t.Fatal("s should be zero, but it is not")
		}
	})

	t.Run("short long", func(t *testing.T) {
		s := NewScalar()
		_, err := s.SetCanonicalBytes([]byte{
			0xf2, 0x44, 0x58, 0xab, 0x92, 0xc2, 0x78, 0x23,
			0x55, 0x8f, 0xc5, 0x8d, 0x72, 0xc2, 0x6c, 0x21,
			0x90, 0x36, 0xd6, 0xae, 0x49, 0xdb, 0x4e, 0xc4,
			0xe9, 0x23, 0xca, 0x7c, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
		})
		if err == nil {
			t.Fatal(err)
		}
		if s.Equal(NewScalar()) == 0 {
			t.Fatal("s should be zero, but it is not")
		}
	})
}

func TestSetBytesWithClamping(t *testing.T) {
	f := func(x [57]byte) bool {
		s, err := NewScalar().SetBytesWithClamping(x[:])
		if err != nil {
			t.Fatal(err)
		}
		return (s.s[0]&0x02) == 0 && (s.s[55]&0x80) != 0
	}
	if err := quick.Check(f, nil); err != nil {
		t.Error(err)
	}
}
